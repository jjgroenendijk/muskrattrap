#include <Arduino.h> // Should be first for core definitions
#include <avr/wdt.h> // Ensure Watchdog Timer definitions are included early
#include "TheThingsNetwork_HANIoT.h"
#include "HAN_IoT_Shield.h"
#include "secrets.h"
#include "encoder.h"
#include "decoder.h"
#include "IOTShieldConfig.h"
#include "knightRider.h"
#include "test.h"
#include "doorSensor.h"
#include "catchSensor.h"
#include "displacementSensor.h"
#include "batterySensor.h"
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>

// --- LoRaWAN Node: Event-Driven, Periodic, and Duty Cycle Compliant Firmware ---
/**
 * @file nodeCode.ino
 * @brief LoRaWAN muskrat trap node firmware: event-driven, periodic, and duty cycle compliant.
 *
 * This firmware implements an ultra-low-power LoRaWAN node for muskrat trap monitoring.
 * It supports event-driven and periodic (heartbeat) transmissions, duty cycle compliance,
 * debounce for event sends, and minimal binary payloads. All logic is documented in Doxygen format.
 *
 * @section Features
 * - Event-driven and periodic LoRaWAN transmission
 * - Duty cycle and debounce enforcement
 * - Minimal, binary payloads
 * - Doxygen-style comments for educational clarity
 *
 * @note On Leonardo (ATmega32u4), only pins 2 (INT1) and 3 (INT0) are true external interrupts.
 *       Pins 8/9 (used by HAN IoT Shield buttons) require Pin Change Interrupts (PCINT) or polling.
 */

// --- Configuration ---
/**
 * @def MIN_SEND_INTERVAL_MS
 * @brief Minimum interval (ms) between transmissions (duty cycle compliance).
 * @details Set to 12s for demo; increase for production.
 */
#define MIN_SEND_INTERVAL_MS 10000UL ///< Minimum interval (ms) between transmissions (set to 10s for testing)
/**
 * @def EVENT_DEBOUNCE_MS
 * @brief Debounce time (ms) for event-triggered sends.
 */
#define EVENT_DEBOUNCE_MS 2000UL
/**
 * @def HEARTBEAT_INTERVAL_MS
 * @brief Heartbeat interval (ms) for periodic transmission.
 * @details Set to 10s for testing; adjust as needed.
 */
#define HEARTBEAT_INTERVAL_MS 10000UL

// --- Global Flags ---
volatile bool eventTriggered = false;         ///< Generic event flag, can be repurposed or used alongside specific ones
volatile bool heartbeatTriggered = false;     ///< Heartbeat (WDT) event flag
volatile bool doorEvent = false;              ///< Door sensor event flag
volatile bool catchEvent = false;             ///< Catch sensor event flag
volatile bool displacementEvent = false;      ///< Displacement sensor event flag

const char *devEui = DEVEUI;  ///< devEUI to be generated by TTN Console
const char *appEui = JOINEUI; ///< appEUI retrieved from TTN Console application
const char *appKey = APPKEY;  ///< appKEY retrieved from TTN Console application

#define loraSerial Serial1    ///< Serial port for LoRa module (Leonardo)
#define debugSerial Serial    ///< Serial port for debugging
// NOTE: For testing, loraCommunication is set to true to enable LoRaWAN transmission every 10 seconds.
bool loraCommunication = true; ///< Set true to use LoRa communication, false for testing without LoRa

#define freqPlan TTN_FP_EU868 ///< Frequency plan for TTN (EU868 or US915)

TheThingsNetwork_HANIoT ttn(loraSerial, debugSerial, freqPlan);

/// Declare the sensor objects
// Renamed objects to avoid conflict with class names (e.g., myDoorSensor instead of doorSensor)
doorSensor myDoorSensor;                ///< Door sensor object
catchSensor myCatchSensor;              ///< Catch sensor object
displacementSensor myDisplacementSensor;///< Displacement sensor object
batterySensor myBatterySensor(&rightGreenLED); ///< Battery sensor object, uses rightGreenLED for indication.
iotShieldPotmeter potmeter2_test(potmeter2); ///< Potmeter object (assumes potmeter2 defined elsewhere)

/**
 * @brief ISR for generic event pin (e.g., pin 2)
 */
void eventISR() {
    eventTriggered = true;
}

/**
 * @brief ISR for door sensor event
 */
void doorSensorISR() {
    doorEvent = true;
    debugSerial.println("DEBUG: Door Sensor ISR triggered");
}

/**
 * @brief ISR for catch sensor event
 */
void catchSensorISR() {
    catchEvent = true;
    debugSerial.println("DEBUG: Catch Sensor ISR triggered");
}

/**
 * @brief ISR for displacement sensor event
 */
void displacementSensorISR() {
    displacementEvent = true;
    debugSerial.println("DEBUG: Displacement Sensor ISR triggered");
}

/**
 * @brief Watchdog Timer interrupt for heartbeat
 */
ISR(WDT_vect) {
    heartbeatTriggered = true;
    debugSerial.println("DEBUG: Heartbeat Timer ISR triggered");
}

// Forward declaration for the sleep placeholder function
void enterSleepModePlaceholder();

/**
 * @brief Arduino setup function. Initializes serial, LoRa, interrupts, and watchdog timer.
 */
void setup()
{
    delay(4000); // Allow bootloader to finish
    if (loraCommunication) loraSerial.begin(57600);
    debugSerial.begin(9600);
    while (!debugSerial && millis() < 10000);

    // Initialize LED pins (assuming these constants are defined in your shield library)
    // Please replace LED_PIN_1 and LED_PIN_2 with the actual constants for your shield's LEDs
    // For example, if your shield uses LED_BUILTIN or specific names like SHIELD_LED_RED.
    // pinMode(LED_BUILTIN, OUTPUT); // Example for a single built-in LED
    // pinMode(LED_RED_PIN, OUTPUT);    // Replace with actual red LED pin constant
    // pinMode(LED_GREEN_PIN, OUTPUT);  // Replace with actual green LED pin constant
    // For now, I'll use placeholder names. You'll need to find the correct defines.
    // If your shield has LEDs associated with e.g. D4, D5:
    pinMode(4, OUTPUT); // Example: Assuming an LED on pin 4
    pinMode(5, OUTPUT); // Example: Assuming an LED on pin 5


    if (loraCommunication) {
        debugSerial.println(F("-- STATUS"));
        ttn.showStatus();
        debugSerial.println(F("-- JOIN"));
        ttn.join(devEui, appEui, appKey);
    }
    pinMode(2, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(2), eventISR, CHANGE);
    // For true event-driven wakeup on other sensors, re-wire to INT0/INT1 or use PCINT (not available on Leonardo for pins 8/9)
    // Setup Watchdog Timer for ~8s interval
    MCUSR &= ~(1 << WDRF);
    WDTCSR |= (1 << WDCE) | (1 << WDE);
    WDTCSR = (1 << WDIE) | (1 << WDP3); // 8s interval, interrupt only
}

static uint32_t lastHeartbeat = 0; ///< Last time a heartbeat was sent (ms)
static uint32_t unixTime = 1717891200; ///< Simulated UNIX time (for demo/testing)
static unsigned long lastSendTime = 0; ///< Last time a payload was sent (ms)
static unsigned long lastEventTime = 0; ///< Last time an event was sent (ms)

/**
 * @brief Main loop: Handles event/heartbeat detection, debounce, state change, and LoRaWAN transmission.
 *
 * The loop is structured as follows:
 *
 * 1. **Atomic Event Flag Handling:**
 *    - Disables interrupts (`cli()`) to safely read and clear all volatile event flags set by ISRs.
 *    - Copies the current state of each event flag (generic, door, catch, displacement, heartbeat) to local variables.
 *    - Resets all event flags to false, then re-enables interrupts (`sei()`).
 *    - This ensures no ISR event is missed or double-counted.
 *
 * 2. **Duty Cycle Enforcement:**
 *    - Checks if the minimum interval (`MIN_SEND_INTERVAL_MS`) has elapsed since the last transmission.
 *    - Prevents any send (event or heartbeat) if the duty cycle would be violated.
 *
 * 3. **Event-Driven Transmission Logic:**
 *    - If any event flag is set (generic or specific sensor), and debounce and duty cycle conditions are met, sets `shouldSend` to true.
 *    - Updates `lastEventTime` to enforce debounce for event-driven sends.
 *
 * 4. **Periodic Heartbeat Transmission Logic:**
 *    - If a heartbeat event (WDT or timed interval) is triggered and duty cycle allows, sets `shouldSend` to true.
 *    - Updates `lastHeartbeat` to track last heartbeat send.
 *
 * 5. **Payload Assembly and Transmission:**
 *    - If `shouldSend` is true:
 *      - Updates `lastSendTime`.
 *      - Simulates sensor state changes with button presses (for demo/testing).
 *      - Reads current sensor states (door, catch, displacement).
 *      - Detects if any state has changed since the last send.
 *      - Reads battery level and updates battery LED.
 *      - Increments simulated UNIX time.
 *      - Assembles a binary payload with all sensor and metadata fields.
 *      - Prints debug output for all sensor states and payload contents.
 *      - (Actual LoRaWAN send is handled elsewhere if enabled.)
 *
 * 6. **Sleep Mode:**
 *    - If no transmission occurred, enters a placeholder sleep mode to conserve energy.
 *    - (To be replaced with actual low-power sleep logic.)
 */
void loop()
{
    bool shouldSend = false; ///< Flag to indicate if a LoRaWAN transmission should occur in this iteration

    // Atomically read and clear volatile event flags set by ISRs
    // This ensures we capture any events that occurred and reset flags for the next cycle.
    cli(); // Disable interrupts to safely access volatile variables
    bool genericEvent = eventTriggered;
    bool specificDoorEvent = doorEvent;
    bool specificCatchEvent = catchEvent;
    bool specificDisplacementEvent = displacementEvent;
    bool WDTHeartbeat = heartbeatTriggered;
    // Reset all event flags
    eventTriggered = false;
    doorEvent = false;
    catchEvent = false;
    displacementEvent = false;
    heartbeatTriggered = false;
    sei(); // Re-enable interrupts

    unsigned long now = millis(); ///< Current time in milliseconds
    /// Check if enough time has passed since the last transmission to comply with duty cycle
    bool canSend = (now - lastSendTime) > MIN_SEND_INTERVAL_MS;

    // --- Event-Driven Transmission Logic ---
    // Check if any sensor event was triggered, if we are allowed to send (duty cycle),
    // and if enough time has passed since the last event (debounce).
    if ((genericEvent || specificDoorEvent || specificCatchEvent || specificDisplacementEvent) && canSend && (now - lastEventTime > EVENT_DEBOUNCE_MS)) {
        debugSerial.println("DEBUG: Event-driven send triggered.");
        shouldSend = true;
        lastEventTime = now; ///< Update the time of the last event-driven send attempt
    }

    // --- Periodic Heartbeat Transmission Logic ---
    // Check if a WDT heartbeat occurred OR if the timed heartbeat interval has elapsed,
    // AND if we are allowed to send (duty cycle).
    if ((WDTHeartbeat || (now - lastHeartbeat > HEARTBEAT_INTERVAL_MS)) && canSend) {
        debugSerial.println(WDTHeartbeat ? "DEBUG: WDT Heartbeat triggered send." : "DEBUG: Timed Heartbeat triggered send.");
        shouldSend = true;
        lastHeartbeat = now; ///< Update the time of the last heartbeat send attempt
    }

    // --- Payload Assembly and Transmission ---
    if (shouldSend) {
        lastSendTime = now; ///< Update the time of the last transmission

        // Simulate sensor state changes with buttons for testing/demo
        // These would typically be replaced with actual sensor readings or ISR-driven flags in a real deployment.
        static bool doorClosed = false;
        static bool catchDetected = false;
        if (redButton.wasPressedDebounced()) {
            doorClosed = !doorClosed;
            debugSerial.println("Red button pressed: doorClosed toggled");
        }
        if (blackButton.wasPressedDebounced()) {
            catchDetected = !catchDetected;
            debugSerial.println("Black button pressed: catchDetected toggled");
        }

        // Store previous sensor states to detect changes
        static bool prevDoorClosed = false;
        static bool prevCatchDetected = false;
        static bool prevDisplacement = false;

        // Read current sensor states
        bool currentDoorClosed = myDoorSensor.getDoorStatus();
        bool currentCatchDetected = myCatchSensor.getCatchStatus();
        bool currentDisplacement = myDisplacementSensor.getDisplacementStatus();

        /// Determine if any critical sensor state has changed since the last check
        bool stateChanged = (currentDoorClosed != prevDoorClosed) ||
                            (currentCatchDetected != prevCatchDetected) ||
                            (currentDisplacement != prevDisplacement);

        // Add a debug message indicating the reason for sending
        if (stateChanged) {
            debugSerial.println("DEBUG: State change detected, preparing payload.");
        } else {
            debugSerial.println("DEBUG: No primary state change, but sending (e.g., heartbeat, generic event, or initial send).");
        }

        // Update previous states for the next iteration
        prevDoorClosed = currentDoorClosed;
        prevCatchDetected = currentCatchDetected;
        prevDisplacement = currentDisplacement;

        // Read battery level (simulated via potentiometer A1)
        int potRaw = analogRead(A1);
        uint8_t batteryLevelPct = map(potRaw, 0, 1023, 0, 100);
        myBatterySensor.setBatteryLevel(batteryLevelPct);

        // Increment simulated UNIX time for payload
        // unixTime is now a file-scope static variable, increment here only
        unixTime++;

        // Assemble and send payload
        payloadEncoder encoder; ///< Payload encoder object
        uint32_t id = 12345;    ///< Device ID for payload (example)
        uint8_t version = 1;    ///< Payload format version (example)

        // Set payload fields
        encoder.set_id(id);
        encoder.set_version(version);
        encoder.set_doorStatus(currentDoorClosed);
        encoder.set_catchDetect(currentCatchDetected);
        encoder.set_trapDisplacement(currentDisplacement);
        encoder.set_batteryStatus(myBatterySensor.getBatteryLevel());
        encoder.set_unixTime(unixTime);

        encoder.composePayload(); ///< Assemble the binary payload
        uint8_t *payloadBuffer = encoder.getPayload(); ///< Get pointer to the payload buffer
        uint8_t payloadSize = encoder.getPayloadSize();   ///< Get the size of the payload

        // --- Debug Output: Sensor and Payload Status ---
        debugSerial.println("================ SENSOR & PAYLOAD STATUS ================");
        debugSerial.print("DOOR:           ");
        debugSerial.println(currentDoorClosed ? "CLOSED (1)" : "OPEN (0)");
        debugSerial.print("CATCH:          ");
        debugSerial.println(currentCatchDetected ? "DETECTED (1)" : "NONE (0)");
        debugSerial.print("DISPLACEMENT:   ");
        debugSerial.println(currentDisplacement ? "DISPLACED (1)" : "STABLE (0)");
        debugSerial.print("BATTERY:        Raw=");
        debugSerial.print(potRaw);
        debugSerial.print("  %=");
        debugSerial.println(batteryLevelPct);
        debugSerial.print("ID:             ");
        debugSerial.println(id);
        debugSerial.print("VERSION:        ");
        debugSerial.println(version);
        debugSerial.print("UNIXTIME:       ");
        debugSerial.println(unixTime);
        debugSerial.print("PAYLOAD (HEX):  ");
        for (uint8_t i = 0; i < payloadSize; ++i) {
            debugSerial.print(payloadBuffer[i], HEX);
            debugSerial.print(i < payloadSize - 1 ? " " : "");
        }
        debugSerial.println();
        debugSerial.println("========================================================");

        // --- LoRaWAN Transmission ---
        if (loraCommunication) {
            ttn.sendBytes(payloadBuffer, payloadSize);
            // Note: A long delay after sending might not be ideal for responsiveness
            // or power saving if not entering deep sleep. Consider alternatives.
            delay(10000); // Delay to allow ACK or prevent immediate re-send (adjust as needed)
        }
    }

    // --- Sleep Mode ---
    // If no transmission occurred, enter a placeholder sleep mode.
    // In a real deployment, this would be a low-power sleep mode.
    if (!shouldSend) {
        enterSleepModePlaceholder();
    }
}

// BUTTON/LED MAPPING CHECK
// HAN IoT Shield layout (see HAN_IoT_Shield.h):
// - Red Button: PIN_SWITCH_RED (pin 9)
// - Black Button: PIN_SWITCH_BLACK (pin 8)
// - leftRedLED: LED1 (door status)
// - rightRedLED: LED2 (catch status)
// - leftGreenLED: LED3 (displacement status)
// - rightGreenLED: LED4 (battery level)
//
// CODE MAPPING:
// - doorSensor controls leftRedLED (OK)
// - catchSensor controls rightRedLED (OK)
// - displacementSensor now controls leftGreenLED (OK, unique LED)
//
/**
 * @brief Placeholder for low-power sleep mode functionality.
 *
 * This function is intended to be replaced with actual code that puts the
 * microcontroller into a low-power sleep state to conserve battery.
 * For now, it's a placeholder and does nothing.
 */
void enterSleepModePlaceholder() {
    // Future implementation: Put the microcontroller to sleep.
    // For example, using set_sleep_mode(SLEEP_MODE_PWR_DOWN) and sleep_enable().
    debugSerial.println("DEBUG: enterSleepModePlaceholder() called. MCU would sleep here.");
    // A small delay can simulate time spent in sleep for testing purposes.
    // Remove or adjust this delay in a real low-power implementation.
    delay(100);
}
