#include <Arduino.h> // Should be first for core definitions
#include "TheThingsNetwork_HANIoT.h"
#include "HAN_IoT_Shield.h"
#include "secrets.h"
#include "encoder.h"
#include "decoder.h"
#include "IOTShieldConfig.h"
#include "knightRider.h"
#include "test.h"
#include "doorSensor.h"
#include "catchSensor.h"
#include "displacementSensor.h"
#include "batterySensor.h"
// #include <Arduino.h> // Duplicate, already at the top
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/wdt.h>

volatile bool eventTriggered = false; // Generic event flag, can be repurposed or used alongside specific ones
volatile bool heartbeatTriggered = false;

// Volatile flags for specific sensor events, to be set by ISRs
volatile boolean doorEvent = false;
volatile boolean catchEvent = false;
volatile boolean displacementEvent = false;

const char *devEui = DEVEUI;  ///< devEUI to be generated by TTN Console
const char *appEui = JOINEUI; ///< appEUI retrieve from TTN Console application
const char *appKey = APPKEY;  ///< appKEY rtrieve from TTN Console application

// Use Serial1 directly for Leonardo
#define loraSerial Serial1
#define debugSerial Serial
bool loraCommunication = false; ///< Set to true if you want to use LoRa communication, false for testing without LoRa

// Replace REPLACE_ME with TTN_FP_EU868 or TTN_FP_US915
#define freqPlan TTN_FP_EU868

TheThingsNetwork_HANIoT ttn(loraSerial, debugSerial, freqPlan);

// iotShieldTempSensor temperatureSensor;

/// Declare the sensor objects
// Renamed objects to avoid conflict with class names (e.g., myDoorSensor instead of doorSensor)
doorSensor myDoorSensor;
catchSensor myCatchSensor;
displacementSensor myDisplacementSensor;
batterySensor myBatterySensor;
iotShieldPotmeter potmeter2_test(potmeter2); // Assuming potmeter2 is defined elsewhere (e.g. IOTShieldConfig.cpp)

// ISR for event pin (e.g., pin 2) - Can be repurposed or kept for a generic/test event
void eventISR() {
    eventTriggered = true; // Example: A generic event occurred
    // For specific sensors, you might set their flags here if pin 2 is used for one of them
    // e.g., if pin 2 is door sensor: doorEvent = true;
}

// Placeholder ISRs for individual sensors
// These would be attached to specific sensor pins if they were interrupt-capable
// and if those pins were different from the generic event pin.
void doorSensorISR() {
    doorEvent = true;
    debugSerial.println("DEBUG: Door Sensor ISR triggered");
}

void catchSensorISR() {
    catchEvent = true;
    debugSerial.println("DEBUG: Catch Sensor ISR triggered");
}

void displacementSensorISR() {
    displacementEvent = true;
    debugSerial.println("DEBUG: Displacement Sensor ISR triggered");
}

// Watchdog Timer interrupt
ISR(WDT_vect) {
    heartbeatTriggered = true;
}

void setup()
{
    delay(4000); // Allow bootloader to finish before using serial ports

    if (loraCommunication)
    {
        loraSerial.begin(57600);
    }

    debugSerial.begin(9600);

    // Wait a maximum of 10s for Serial Monitor
    while (!debugSerial && millis() < 10000)
        ;

    if (loraCommunication)
    {
        debugSerial.println(F("-- STATUS"));
        ttn.showStatus();

        debugSerial.println(F("-- JOIN"));
        ttn.join(devEui, appEui, appKey);
    }
    // Attach interrupt to pin 2 (INT1) for event-driven wakeup
    pinMode(2, INPUT_PULLUP); // Use as event input
    attachInterrupt(digitalPinToInterrupt(2), eventISR, CHANGE); // Existing generic event interrupt on pin 2

    // Placeholder attachInterrupt calls for specific sensors.
    // WARNING: Pins 8 (PIN_SWITCH_BLACK) and 9 (PIN_SWITCH_RED) used by default by
    // HAN_IoT_Shield buttons are NOT directly compatible with attachInterrupt() on Arduino Leonardo.
    // These lines are for structural illustration. Real implementation would require:
    // 1. Re-wiring sensors to interrupt-capable pins (0, 1, 2, 3, 7).
    // 2. Or, implementing Pin Change Interrupts (PCINT) for pins 8 & 9.

    // Assuming doorSensor uses PIN_SWITCH_RED (default 9) - NEEDS PIN CHANGE INTERRUPT or RE-WIRING
    // pinMode(PIN_SWITCH_RED, INPUT_PULLUP); // Ensure pin is input pullup
    // attachInterrupt(digitalPinToInterrupt(PIN_SWITCH_RED), doorSensorISR, FALLING); // Placeholder - PIN 9 NOT OK for attachInterrupt

    // Assuming catchSensor uses PIN_SWITCH_BLACK (default 8) - NEEDS PIN CHANGE INTERRUPT or RE-WIRING
    // pinMode(PIN_SWITCH_BLACK, INPUT_PULLUP); // Ensure pin is input pullup
    // attachInterrupt(digitalPinToInterrupt(PIN_SWITCH_BLACK), catchSensorISR, FALLING); // Placeholder - PIN 8 NOT OK for attachInterrupt

    // Assuming displacementSensor might use another pin or a different mechanism.
    // If it uses a button on an interrupt-capable pin (e.g., pin 3 if available and wired):
    // const int DISPLACEMENT_PIN = 3; // Example if displacement sensor is on pin 3
    // pinMode(DISPLACEMENT_PIN, INPUT_PULLUP);
    // attachInterrupt(digitalPinToInterrupt(DISPLACEMENT_PIN), displacementSensorISR, FALLING); // Placeholder

    // Setup Watchdog Timer for ~8s interval (max for WDT)
    MCUSR &= ~(1 << WDRF);
    WDTCSR |= (1 << WDCE) | (1 << WDE);
    WDTCSR = (1 << WDIE) | (1 << WDP3); // 8s interval, interrupt only
}

// Placeholder for actual sleep mode implementation
void enterSleepModePlaceholder() {
    // Actual sleep implementation would go here, e.g.:
    // set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    // sleep_enable();
    // sei(); // Enable interrupts before sleeping
    // sleep_cpu();
    // sleep_disable();
    // cli(); // Disable interrupts after waking, if necessary for critical sections
    debugSerial.println("DEBUG: enterSleepModePlaceholder() called. Actual sleep would occur here.");
    delay(100); // Simulate time spent sleeping for now
}

void loop()
{
    static uint32_t lastHeartbeat = 0;
    static uint32_t unixTime = 1717891200;
    bool shouldSend = false;

    // Check if event or heartbeat triggered
    cli(); // Disable interrupts for critical section
    bool genericEvent = eventTriggered;
    bool specificDoorEvent = doorEvent;
    bool specificCatchEvent = catchEvent;
    bool specificDisplacementEvent = displacementEvent;
    bool WDTHeartbeat = heartbeatTriggered;

    eventTriggered = false; // Reset flags
    doorEvent = false;
    catchEvent = false;
    displacementEvent = false;
    heartbeatTriggered = false;
    sei(); // Re-enable interrupts

    if (genericEvent) {
        debugSerial.println("DEBUG: Generic event triggered send.");
        shouldSend = true;
    }
    if (specificDoorEvent) {
        debugSerial.println("DEBUG: Door event triggered send.");
        shouldSend = true;
    }
    if (specificCatchEvent) {
        debugSerial.println("DEBUG: Catch event triggered send.");
        shouldSend = true;
    }
    if (specificDisplacementEvent) {
        debugSerial.println("DEBUG: Displacement event triggered send.");
        shouldSend = true;
    }

    if (WDTHeartbeat || (millis() - lastHeartbeat > HEARTBEAT_INTERVAL_MS)) {
        debugSerial.println(WDTHeartbeat ? "DEBUG: WDT Heartbeat triggered send." : "DEBUG: Timed Heartbeat triggered send.");
        shouldSend = true;
        lastHeartbeat = millis();
    }

    if (shouldSend) {
        // unixTime++; // unixTime is incremented further down, avoid double increment

        ///< Toggle door and catch status on button press using debounced method
        static bool doorClosed = false;
        static bool catchDetected = false;

        if (redButton.wasPressedDebounced()) {
            doorClosed = !doorClosed;
            debugSerial.println("Red button pressed: doorClosed toggled");
        }
        if (blackButton.wasPressedDebounced()) {
            catchDetected = !catchDetected;
            debugSerial.println("Black button pressed: catchDetected toggled");
        }

        ///< Track previous sensor states and heartbeat
        static bool prevDoorClosed = false;
        static bool prevCatchDetected = false;
        static bool prevDisplacement = false;
        static unsigned long lastSendTime = 0;

        ///< Read current sensor states
        bool currentDoorClosed = myDoorSensor.getDoorStatus();
        bool currentCatchDetected = myCatchSensor.getCatchStatus();
        bool currentDisplacement = myDisplacementSensor.getDisplacementStatus();

        ///< Check if any state changed
        bool stateChanged = (currentDoorClosed != prevDoorClosed) || (currentCatchDetected != prevCatchDetected) || (currentDisplacement != prevDisplacement);
        unsigned long now = millis();
        bool heartbeatElapsed = (now - lastSendTime) > HEARTBEAT_INTERVAL_MS;

        ///< Check the battery level
        int potRaw = analogRead(A1); // Directly read potmeter2 (A1)
        uint8_t batteryLevelPct = map(potRaw, 0, 1023, 0, 100);
        myBatterySensor.setBatteryLevel(batteryLevelPct); // Corrected to use myBatterySensor

        ///< Only send payload if state changed or heartbeat interval elapsed
        static uint32_t unixTime = 1717891200; // Start time: 2024-06-09 00:00:00 UTC
        unixTime++;
        if (stateChanged || heartbeatElapsed) {
            prevDoorClosed = currentDoorClosed;
            prevCatchDetected = currentCatchDetected;
            prevDisplacement = currentDisplacement;
            lastSendTime = now;

            // Compose payload
            payloadEncoder encoder;
            uint32_t id = 12345; // Example ID
            uint8_t version = 1;
            encoder.set_id(id);
            encoder.set_version(version);
            encoder.set_doorStatus(currentDoorClosed);
            encoder.set_catchDetect(currentCatchDetected);
            encoder.set_trapDisplacement(currentDisplacement);
            encoder.set_batteryStatus(myBatterySensor.getBatteryLevel());
            encoder.set_unixTime(unixTime); // Use incrementing unixTime
            encoder.composePayload();
            uint8_t *payloadBuffer = encoder.getPayload();
            uint8_t payloadSize = encoder.getPayloadSize();

            debugSerial.println("================ SENSOR & PAYLOAD STATUS ===============");
            debugSerial.print("DOOR:           ");
            debugSerial.println(currentDoorClosed ? "CLOSED (1)" : "OPEN (0)");
            debugSerial.print("CATCH:          ");
            debugSerial.println(currentCatchDetected ? "DETECTED (1)" : "NONE (0)");
            debugSerial.print("DISPLACEMENT:   ");
            debugSerial.println(currentDisplacement ? "DISPLACED (1)" : "STABLE (0)");
            debugSerial.print("BATTERY:        Raw=");
            debugSerial.print(potRaw);
            debugSerial.print("  %=");
            debugSerial.println(batteryLevelPct);
            debugSerial.print("ID:             ");
            debugSerial.println(id);
            debugSerial.print("VERSION:        ");
            debugSerial.println(version);
            debugSerial.print("UNIXTIME:       ");
            debugSerial.println(unixTime);
            debugSerial.print("PAYLOAD (HEX):  ");
            for (uint8_t i = 0; i < payloadSize; ++i) {
                debugSerial.print(payloadBuffer[i], HEX);
                debugSerial.print(i < payloadSize - 1 ? " " : "");
            }
            debugSerial.println();
            debugSerial.println("========================================================");

            if (loraCommunication)
            {
                // Send it off
                ttn.sendBytes(payloadBuffer, payloadSize);
                delay(10000);
            }
        }
    }

    // Sleep logic is currently disabled for debugging and bring-up. Device will remain awake and responsive.
    // To re-enable low-power operation, uncomment the sleep section in loop().
    
    // Placeholder call to sleep function.
    // In a full implementation, this would put the device to sleep until an interrupt (sensor event or WDT) wakes it.
    if (!shouldSend) { // Only attempt to sleep if no send was triggered in this iteration
      enterSleepModePlaceholder();
    }
    // Old sleep logic:
    // set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    // sleep_enable();
    // sleep_cpu();
    // sleep_disable();
}

// NOTE: On Leonardo (ATmega32u4), Serial1 is available, but pin change interrupts are not available on pins 8/9 as on Uno. Only INT0 (pin 3) and INT1 (pin 2) are true external interrupts. For true event-driven wakeup, use these pins for critical events if possible. Otherwise, use polling or a hybrid approach for non-interrupt pins.
// Pin 8: PIN_SWITCH_BLACK (used by blackButton, likely for catchSensor)
// Pin 9: PIN_SWITCH_RED (used by redButton, likely for doorSensor)
// These require Pin Change Interrupts (PCINT) or re-wiring for true interrupt-driven behavior.
