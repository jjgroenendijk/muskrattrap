#include "TheThingsNetwork_HANIoT.h"
#include "HAN_IoT_Shield.h"
#include "secrets.h"
#include "encoder.h"
#include "decoder.h"
#include "IOTShieldConfig.h"
#include "knightRider.h"
#include "test.h"
#include "doorSensor.h"
#include "catchSensor.h"
#include "displacementSensor.h"
#include "batterySensor.h"
#include <Arduino.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/wdt.h>

volatile bool eventTriggered = false;
volatile bool heartbeatTriggered = false;

const char *devEui = DEVEUI;  ///< devEUI to be generated by TTN Console
const char *appEui = JOINEUI; ///< appEUI retrieve from TTN Console application
const char *appKey = APPKEY;  ///< appKEY rtrieve from TTN Console application

// Use Serial1 directly for Leonardo
#define loraSerial Serial1
#define debugSerial Serial
bool loraCommunication = false; ///< Set to true if you want to use LoRa communication, false for testing without LoRa

// Replace REPLACE_ME with TTN_FP_EU868 or TTN_FP_US915
#define freqPlan TTN_FP_EU868

TheThingsNetwork_HANIoT ttn(loraSerial, debugSerial, freqPlan);

// iotShieldTempSensor temperatureSensor;

/// Declare the button objects
doorSensor doorSensor;
catchSensor catchSensor;
displacementSensor displacementSensor;
batterySensor batterySensor;
iotShieldPotmeter potmeter2_test(potmeter2);

// ISR for event pin (e.g., pin 2)
void eventISR() {
    eventTriggered = true;
}

// Watchdog Timer interrupt
ISR(WDT_vect) {
    heartbeatTriggered = true;
}

void setup()
{
    delay(4000); // Allow bootloader to finish before using serial ports

    if (loraCommunication)
    {
        loraSerial.begin(57600);
    }

    debugSerial.begin(9600);

    // Wait a maximum of 10s for Serial Monitor
    while (!debugSerial && millis() < 10000)
        ;

    if (loraCommunication)
    {
        debugSerial.println(F("-- STATUS"));
        ttn.showStatus();

        debugSerial.println(F("-- JOIN"));
        ttn.join(devEui, appEui, appKey);
    }
    // Attach interrupt to pin 2 (INT1) for event-driven wakeup
    pinMode(2, INPUT_PULLUP); // Use as event input
    attachInterrupt(digitalPinToInterrupt(2), eventISR, CHANGE);
    // Setup Watchdog Timer for ~8s interval (max for WDT)
    MCUSR &= ~(1 << WDRF);
    WDTCSR |= (1 << WDCE) | (1 << WDE);
    WDTCSR = (1 << WDIE) | (1 << WDP3); // 8s interval, interrupt only
}

void loop()
{
    static uint32_t lastHeartbeat = 0;
    static uint32_t unixTime = 1717891200;
    bool shouldSend = false;

    // Check if event or heartbeat triggered
    cli();
    bool event = eventTriggered;
    bool heartbeat = heartbeatTriggered;
    eventTriggered = false;
    heartbeatTriggered = false;
    sei();

    if (event) {
        shouldSend = true;
    }
    if (heartbeat || (millis() - lastHeartbeat > HEARTBEAT_INTERVAL_MS)) {
        shouldSend = true;
        lastHeartbeat = millis();
    }

    if (shouldSend) {
        unixTime++;

        ///< Toggle door and catch status on button press using debounced method
        static bool doorClosed = false;
        static bool catchDetected = false;

        if (redButton.wasPressedDebounced()) {
            doorClosed = !doorClosed;
        }
        if (blackButton.wasPressedDebounced()) {
            catchDetected = !catchDetected;
        }

        // REMOVE these lines:
        // debugSerial.print(F("-- DOOR SENSOR: "));
        // debugSerial.println(doorClosed ? "CLOSED" : "OPEN");
        // doorSensor.setDoorStatus(doorClosed);

        // debugSerial.print(F("-- CATCH SENSOR: "));
        // debugSerial.println(catchDetected ? "DETECTED" : "NONE");
        // catchSensor.setCatchStatus(catchDetected);

        // debugSerial.print(F("-- DISPLACEMENT SENSOR: "));
        // debugSerial.println(displacement ? "DISPLACED" : "STABLE");
        // displacementSensor.setDisplacementStatus(displacement);

        // debugSerial.print(F("-- BATTERY LEVEL (Potmeter2): "));
        // debugSerial.print(potRaw);
        // debugSerial.print(F(" -> %: "));
        // debugSerial.println(batteryLevelPct);

        ///< Track previous sensor states and heartbeat
        static bool prevDoorClosed = false;
        static bool prevCatchDetected = false;
        static bool prevDisplacement = false;
        static unsigned long lastSendTime = 0;

        ///< Read current sensor states
        bool currentDoorClosed = doorSensor.getDoorStatus();
        bool currentCatchDetected = catchSensor.getCatchStatus();
        bool currentDisplacement = displacementSensor.getDisplacementStatus();

        ///< Check if any state changed
        bool stateChanged = (currentDoorClosed != prevDoorClosed) || (currentCatchDetected != prevCatchDetected) || (currentDisplacement != prevDisplacement);
        unsigned long now = millis();
        bool heartbeatElapsed = (now - lastSendTime) > HEARTBEAT_INTERVAL_MS;

        ///< Check the battery level
        int potRaw = analogRead(A1); // Directly read potmeter2 (A1)
        uint8_t batteryLevelPct = map(potRaw, 0, 1023, 0, 100);
        batterySensor.setBatteryLevel(batteryLevelPct);

        ///< Only send payload if state changed or heartbeat interval elapsed
        static uint32_t unixTime = 1717891200; // Start time: 2024-06-09 00:00:00 UTC
        unixTime++;
        if (stateChanged || heartbeatElapsed) {
            prevDoorClosed = currentDoorClosed;
            prevCatchDetected = currentCatchDetected;
            prevDisplacement = currentDisplacement;
            lastSendTime = now;

            // Compose payload
            payloadEncoder encoder;
            uint32_t id = 12345; // Example ID
            uint8_t version = 1;
            encoder.set_id(id);
            encoder.set_version(version);
            encoder.set_doorStatus(currentDoorClosed);
            encoder.set_catchDetect(currentCatchDetected);
            encoder.set_trapDisplacement(currentDisplacement);
            encoder.set_batteryStatus(batterySensor.getBatteryLevel());
            encoder.set_unixTime(unixTime); // Use incrementing unixTime
            encoder.composePayload();
            uint8_t *payloadBuffer = encoder.getPayload();
            uint8_t payloadSize = encoder.getPayloadSize();

            debugSerial.println("================ SENSOR & PAYLOAD STATUS ===============");
            debugSerial.print("DOOR:           ");
            debugSerial.println(currentDoorClosed ? "CLOSED (1)" : "OPEN (0)");
            debugSerial.print("CATCH:          ");
            debugSerial.println(currentCatchDetected ? "DETECTED (1)" : "NONE (0)");
            debugSerial.print("DISPLACEMENT:   ");
            debugSerial.println(currentDisplacement ? "DISPLACED (1)" : "STABLE (0)");
            debugSerial.print("BATTERY:        Raw=");
            debugSerial.print(potRaw);
            debugSerial.print("  %=");
            debugSerial.println(batteryLevelPct);
            debugSerial.print("ID:             ");
            debugSerial.println(id);
            debugSerial.print("VERSION:        ");
            debugSerial.println(version);
            debugSerial.print("UNIXTIME:       ");
            debugSerial.println(unixTime);
            debugSerial.print("PAYLOAD (HEX):  ");
            for (uint8_t i = 0; i < payloadSize; ++i) {
                debugSerial.print(payloadBuffer[i], HEX);
                debugSerial.print(i < payloadSize - 1 ? " " : "");
            }
            debugSerial.println();
            debugSerial.println("========================================================");

            if (loraCommunication)
            {
                // Send it off
                ttn.sendBytes(payloadBuffer, payloadSize);
                delay(10000);
            }
        }
    }

    // Sleep logic is currently disabled for debugging and bring-up. Device will remain awake and responsive.
    // To re-enable low-power operation, uncomment the sleep section in loop().
    // Sleep until next interrupt (event or watchdog)
    // set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    // sleep_enable();
    // sleep_cpu();
    // sleep_disable();
}

// NOTE: On Leonardo (ATmega32u4), Serial1 is available, but pin change interrupts are not available on pins 8/9 as on Uno. Only INT0 (pin 3) and INT1 (pin 2) are true external interrupts. For true event-driven wakeup, use these pins for critical events if possible. Otherwise, use polling or a hybrid approach for non-interrupt pins.