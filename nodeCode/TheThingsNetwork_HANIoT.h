/*--------------------------------------------------------------------
  This file is part of the HAN IoT shield library.

  This code is free software: Use of this source code is governed by the
  MIT license that can be found in the LICENSE file.
  Original Copyright Â© 2017 The Things Network

  The program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  --------------------------------------------------------------------*/

/*!
 * \file TheThingsNetwork_HANIoT.h
 * \brief Class to utilize RN2483 LoRaWAN radio in HAN oT Class.
 * The class is an extention of the original class as was delivered by 
 * The Things Network.
 * \author Remko Welling (remko.welling@han.nl)
 * \date 22-2-2019
 * \version 1.0
 * 
 * Version|Date        |Note
 * -------|------------|----
 * 1.0    | 22-2-2019  | Initial version, addidtions to allow the use of 
 *        |            | devEui generated by console of The Things Network.
 * \brief Header file for the TheThingsNetwork_HANIoT class, providing an interface
 * for LoRaWAN communication using RN2483 or similar modules with the HAN IoT Shield.
 * This class is an extension of the original The Things Network library, with
 * modifications to support features like user-provided DevEUI.
 */

#ifndef _THETHINGSNETWORK_HAN_IOT_H_
#define _THETHINGSNETWORK_HAN_IOT_H_

#include <Arduino.h>
#include <Stream.h>
#if defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_ARCH_SAMD)
  #include <avr/pgmspace.h>
#else
  #include <pgmspace.h>
#endif

/** \def TTN_DEFAULT_SF
 * \brief Default Spreading Factor (SF) for LoRaWAN transmissions.
 * Typically SF7, but can be overridden.
 */
#define TTN_DEFAULT_SF 7

/** \def TTN_DEFAULT_FSB
 * \brief Default Frequency Sub-Band (FSB) for US915/AU915 frequency plans.
 * FSB 2 is commonly used.
 */
#define TTN_DEFAULT_FSB 2

/** \def TTN_RETX
 * \brief Default number of retransmissions for confirmed uplinks.
 * Set to "7" as a string, as expected by the RN2483 module.
 */
#define TTN_RETX "7"

#define CMP_OK 0
#define CMP_ON 1
#define CMP_OFF 2
#define CMP_ACCEPTED 3
#define CMP_MAC_TX_OK 4
#define CMP_MAC_RX 5
#define CMP_RN2483 6

/** \def TTN_PWRIDX_EU868
 *  \brief MAC command power index for EU868 MHz frequency plan.
 *  "1" usually corresponds to 14dBm.
 */
#define TTN_PWRIDX_EU868 "1"

/** \def TTN_PWRIDX_US915
 *  \brief MAC command power index for US915 MHz frequency plan.
 *  "5" usually corresponds to 20dBm (or max allowed by module).
 */
#define TTN_PWRIDX_US915 "5"

/** \def TTN_PWRIDX_AU915
 *  \brief MAC command power index for AU915 MHz frequency plan.
 *  "5" usually corresponds to 20dBm (or max allowed by module).
 */
#define TTN_PWRIDX_AU915 "5"

/** \def TTN_PWRIDX_AS920_923
 *  \brief MAC command power index for AS920-923 MHz frequency plan.
 *  \todo Check if "0" is supported by firmware for maximum power. Currently uses "1".
 */
#define TTN_PWRIDX_AS920_923 "1" // TODO: should be 0, but the current RN2903AS firmware doesn't accept that value (probably still using EU868: 1=14dBm)
// The following defines TTN_PWRIDX_AS923_925, TTN_PWRIDX_KR920_923, TTN_PWRIDX_IN865_867 were handled by a previous diff.
/** \def TTN_PWRIDX_AS923_925
 *  \brief MAC command power index for AS923-925 MHz frequency plan.
 *  \todo Check if "0" is supported by firmware for maximum power.
 */
#define TTN_PWRIDX_AS923_925 "1" // TODO: should be 0

/** \def TTN_PWRIDX_KR920_923
 *  \brief MAC command power index for KR920-923 MHz frequency plan.
 *  \todo Check if "0" is supported by firmware for maximum power.
 */
#define TTN_PWRIDX_KR920_923 "1" // TODO: should be 0

/** \def TTN_PWRIDX_IN865_867
 *  \brief MAC command power index for IN865-867 MHz frequency plan.
 *  \todo Check if "0" is supported by firmware for maximum power.
 */
#define TTN_PWRIDX_IN865_867 "1" // TODO: should be 0

/** \def TTN_BUFFER_SIZE
 * \brief Size of the internal buffer used for reading responses from the LoRaWAN module.
 * Increased to 300 to accommodate potentially long responses.
 */
#define TTN_BUFFER_SIZE 300

#define SHOW_EUI 0
#define SHOW_BATTERY 1
#define SHOW_APPEUI 2
#define SHOW_DEVEUI 3
#define SHOW_BAND 4
#define SHOW_DATA_RATE 5
#define SHOW_RX_DELAY_1 6
#define SHOW_RX_DELAY_2 7
#define SHOW_VERSION 8
#define SHOW_MODEL 9
#define SHOW_DEVADDR 10

#define ERR_INVALID_SF 0
#define ERR_INVALID_FP 1
#define ERR_UNEXPECTED_RESPONSE 2
#define ERR_SEND_COMMAND_FAILED 3
#define ERR_JOIN_FAILED 4
#define ERR_JOIN_NOT_ACCEPTED 5
#define ERR_PERSONALIZE_NOT_ACCEPTED 6
#define ERR_RESPONSE_IS_NOT_OK 7
#define ERR_KEY_LENGTH 8
#define ERR_CHECK_CONFIGURATION 9

#define SCS_PERSONALIZE_ACCEPTED 0
#define SCS_JOIN_ACCEPTED 1
#define SCS_SUCCESSFUL_TRANSMISSION 2
#define SCS_SUCCESSFUL_TRANSMISSION_RECEIVED 3

#define RADIO_PREFIX 0
#define RADIO_SET 1
#define RADIO_GET 2
#define RADIO_GET_BW 3
#define RADIO_GET_PRLEN 4
#define RADIO_GET_CRC 5
#define RADIO_GET_CR 6
#define RADIO_GET_SF 7


#define SYS_PREFIX 0
#define SYS_SLEEP 1
#define SYS_RESET 2
#define SYS_ERASE_FW 3
#define SYS_FACTORY_RST 4
#define SYS_SET 5
#define SYS_GET 6
#define SYS_GET_VER 7
#define SYS_GET_VDD 8
#define SYS_GET_HWEUI 9
#define SYS_SET_GET_NVM 10
#define SYS_SET_PINDIG 11

#define MAC_PREFIX 0
#define MAC_RESET 1
#define MAC_TX 2
#define MAC_JOIN 3
#define MAC_SAVE 4
#define MAC_FORCE_ENABLE 5
#define MAC_PAUSE 6
#define MAC_RESUME 7
#define MAC_SET 8
#define MAC_GET 9

#define MAC_DEVADDR 0
#define MAC_DEVEUI 1
#define MAC_APPEUI 2
#define MAC_NWKSKEY 3
#define MAC_APPSKEY 4
#define MAC_APPKEY 5
#define MAC_PWRIDX 6
#define MAC_DR 7
#define MAC_ADR 8
#define MAC_BAT 9
#define MAC_RETX 10
#define MAC_LINKCHK 11
#define MAC_RXDELAY1 12
#define MAC_RXDELAY2 13
#define MAC_BAND 14
#define MAC_AR 15
#define MAC_RX2 16
#define MAC_CH 17
#define MAC_GWNB 18
#define MAC_MRGN 19

#define MAC_JOIN_MODE_OTAA 0
#define MAC_JOIN_MODE_ABP 1

#define MAC_CHANNEL_DCYCLE 0
#define MAC_CHANNEL_DRRANGE 1
#define MAC_CHANNEL_FREQ 2
#define MAC_CHANNEL_STATUS 3

#define MAC_TX_TYPE_CNF 0
#define MAC_TX_TYPE_UCNF 1

#define MAC_TABLE 0
#define MAC_GET_SET_TABLE 1
#define MAC_JOIN_TABLE 2
#define MAC_CH_TABLE 3
#define MAC_TX_TABLE 4
#define SYS_TABLE 5
#define RADIO_TABLE 6
#define ERR_MESSAGE 7
#define SUCCESS_MESSAGE 8

/**
 * \typedef port_t
 * \brief Defines the data type for LoRaWAN port numbers.
 * LoRaWAN ports range from 1 to 223 for application payloads.
 */
typedef uint8_t port_t;

/**
 * \enum ttn_response_t
 * \brief Enumerates response codes for various The Things Network operations.
 * These codes indicate the success or failure of operations like sending data.
 */
enum ttn_response_t
{
  TTN_ERROR_SEND_COMMAND_FAILED = (-1),   /*!< Failed to send a command to the module. */
  TTN_ERROR_UNEXPECTED_RESPONSE = (-10),  /*!< Received an unexpected response from the module. */
  TTN_SUCCESSFUL_TRANSMISSION = 1,        /*!< Successfully transmitted an uplink message. */
  TTN_SUCCESSFUL_RECEIVE = 2              /*!< Successfully transmitted and received a downlink message. */
};

/**
 * \enum ttn_fp_t
 * \brief Enumerates supported LoRaWAN frequency plans.
 * Used to configure the module for different geographical regions.
 */
enum ttn_fp_t
{
  TTN_FP_EU868,     /*!< European 868 MHz frequency plan. */
  TTN_FP_US915,     /*!< United States 915 MHz frequency plan. */
  TTN_FP_AU915,     /*!< Australia 915 MHz frequency plan. */
  TTN_FP_AS920_923, /*!< Asia 920-923 MHz frequency plan (e.g., Thailand, Singapore). */
  TTN_FP_AS923_925, /*!< Asia 923-925 MHz frequency plan (e.g., Indonesia, Vietnam). */
  TTN_FP_KR920_923, /*!< South Korea 920-923 MHz frequency plan. */
  TTN_FP_IN865_867  /*!< India 865-867 MHz frequency plan. */
};

/**
 * \class TheThingsNetwork_HANIoT
 * \brief Provides an interface to interact with a LoRaWAN module (e.g., RN2483/RN2903)
 * for The Things Network or other LoRaWAN networks.
 * This class handles AT command communication, message formatting, and status interpretation,
 * simplifying LoRaWAN operations like joining the network and sending/receiving data.
 * It is adapted for use with the HAN IoT Shield.
 */
class TheThingsNetwork_HANIoT
{
protected:
  Stream *modemStream;      /*!< Pointer to the Stream for communication with the LoRaWAN modem. */
  Stream *debugStream;      /*!< Pointer to the Stream for debug output. */
  ttn_fp_t fp;              /*!< Current frequency plan. */
  uint8_t sf;               /*!< Current Spreading Factor. */
  uint8_t fsb;              /*!< Current Frequency Sub-Band (for US/AU plans). */
  bool adr;                 /*!< Current Adaptive Data Rate status (true if enabled). */
  char buffer[TTN_BUFFER_SIZE]; /*!< General purpose buffer for reading responses and constructing commands. */
  bool baudDetermined;      /*!< Flag indicating if auto-baud detection has been successful. */
  void (*messageCallback)(const uint8_t *payload, size_t size, port_t port); /*!< Pointer to the user-defined callback function for downlink messages. */

  // Internal helper methods - documentation primarily in .cpp file for brevity here,
  // but listed for completeness of class structure understanding.
  // Doxygen comments for these are in the .cpp file.
  void clearReadBuffer();
  size_t readLine(char *buffer, size_t size, uint8_t attempts = 3);
  size_t readResponse(uint8_t prefixTable, uint8_t indexTable, uint8_t index, char *buffer, size_t size);
  size_t readResponse(uint8_t table, uint8_t index, char *buffer, size_t size);

  void debugPrintIndex(uint8_t index, const char *value = NULL);
  void debugPrintMessage(uint8_t type, uint8_t index, const char *value = NULL);

  void autoBaud();
  void configureEU868();
  void configureUS915(uint8_t fsb);
  void configureAU915(uint8_t fsb);
  void configureAS920_923();
  void configureAS923_925();
  void configureKR920_923();
  void configureIN865_867();
  void configureChannels(uint8_t fsb);
  bool setSF(uint8_t sf);
  bool waitForOk();

  void sendCommand(uint8_t table, uint8_t index, bool appendSpace, bool print = true);
  bool sendMacSet(uint8_t index, const char *value);
  bool sendChSet(uint8_t index, uint8_t channel, const char *value);
  bool sendJoinSet(uint8_t type);
  bool sendPayload(uint8_t mode, uint8_t port, uint8_t *payload, size_t len);
  void sendGetValue(uint8_t table, uint8_t prefix, uint8_t index); /*!< \brief Sends a command to get a value from the module. (Declaration was missing in original) */

public:
  bool needsHardReset = false; /*!< \brief Flag indicating if the LoRaWAN module may need a hard reset due to unresponsiveness. */

  /**
   * \brief Constructor for TheThingsNetwork_HANIoT.
   * \param modemStream Reference to the Stream object for communication with the LoRaWAN module (e.g., Serial1).
   * \param debugStream Reference to the Stream object for debug output (e.g., Serial).
   * \param fp The frequency plan to use (e.g., TTN_FP_EU868).
   * \param sf The default Spreading Factor to use. If ADR is enabled, this might be overridden by the network. Defaults to TTN_DEFAULT_SF.
   * \param fsb Frequency Sub-Band to use for US915 or AU915 frequency plans (0 for default). Defaults to TTN_DEFAULT_FSB.
   */
  TheThingsNetwork_HANIoT(Stream &modemStream, Stream &debugStream, ttn_fp_t fp, uint8_t sf = TTN_DEFAULT_SF, uint8_t fsb = TTN_DEFAULT_FSB);

  /**
   * \brief Resets the LoRaWAN module and initializes basic configuration.
   * \param adr Boolean indicating whether to enable Adaptive Data Rate (ADR). Defaults to true.
   * \note This is a software reset of the module, followed by configuration.
   */
  void reset(bool adr = true);

  /**
   * \brief Performs a hardware reset of the LoRaWAN module using a specified reset pin.
   * \param resetPin The Arduino pin connected to the module's hardware reset line.
   */
  void resetHard(uint8_t resetPin);

  /**
   * \brief Displays various status parameters of the LoRaWAN module on the debug stream.
   */
  void showStatus();

  /**
   * \brief Retrieves the Hardware EUI (typically used as DevEUI) from the LoRaWAN module.
   * \param buffer Pointer to the character array to store the Hardware EUI.
   * \param size Size of the buffer.
   * \return The number of bytes read into the buffer, or 0 on failure.
   */
  size_t getHardwareEui(char *buffer, size_t size);

  /**
   * \brief Retrieves the Application EUI (AppEUI) from the LoRaWAN module.
   * \param buffer Pointer to the character array to store the AppEUI.
   * \param size Size of the buffer.
   * \return The number of bytes read into the buffer, or 0 on failure.
   */
  size_t getAppEui(char *buffer, size_t size);

  /**
   * \brief Retrieves the module's supply voltage (VDD) in millivolts.
   * \return The supply voltage in mV, or 0 on failure.
   */
  uint16_t getVDD();

  /**
   * \brief Registers a callback function to be invoked when a downlink message is received.
   * \param cb Pointer to the callback function: `void callback(const uint8_t* payload, size_t size, port_t port)`.
   */
  void onMessage(void (*cb)(const uint8_t *payload, size_t size, port_t port));

  /**
   * \brief Provisions the device for OTAA using AppEUI and AppKey. The module's Hardware EUI is used as DevEUI.
   * \param appEui Application EUI (16 hex characters).
   * \param appKey Application Key (32 hex characters).
   * \return True if provisioning commands were accepted, false otherwise.
   */
  bool provision(const char *appEui, const char *appKey);

  /**
   * \brief Provisions the device for OTAA using a specified DevEUI, AppEUI, and AppKey.
   * \param devEui Device EUI (16 hex characters).
   * \param appEui Application EUI (16 hex characters).
   * \param appKey Application Key (32 hex characters).
   * \return True if provisioning commands were accepted, false otherwise.
   */
  bool provision(const char *devEui, const char *appEui, const char *appKey);

  /**
   * \brief Attempts to join the LoRaWAN network using OTAA with AppEUI and AppKey. Module's HWEUI is used as DevEUI.
   * \param appEui Application EUI (16 hex characters).
   * \param appKey Application Key (32 hex characters).
   * \param retries Number of join attempts (-1 for indefinite). Defaults to -1.
   * \param retryDelay Delay in milliseconds between attempts. Defaults to 10000ms.
   * \return True if join was successful, false otherwise.
   */
  bool join(const char *appEui, const char *appKey, int8_t retries = -1, uint32_t retryDelay = 10000);

  /**
   * \brief Attempts to join the LoRaWAN network using OTAA with specified DevEUI, AppEUI, and AppKey.
   * \param devEui Device EUI (16 hex characters).
   * \param appEui Application EUI (16 hex characters).
   * \param appKey Application Key (32 hex characters).
   * \param retries Number of join attempts (-1 for indefinite). Defaults to -1.
   * \param retryDelay Delay in milliseconds between attempts. Defaults to 10000ms.
   * \return True if join was successful, false otherwise.
   */
  bool join(const char *devEui, const char *appEui, const char *appKey, int8_t retries = -1, uint32_t retryDelay = 10000);

  /**
   * \brief Attempts to join the LoRaWAN network using OTAA with previously provisioned keys.
   * \param retries Number of join attempts (-1 for indefinite). Defaults to -1.
   * \param retryDelay Delay in milliseconds between attempts. Defaults to 10000ms.
   * \return True if join was successful, false otherwise.
   */
  bool join(int8_t retries = -1, uint32_t retryDelay = 10000);

  /**
   * \brief Configures the module for Activation By Personalization (ABP) with specified DevAddr, NwkSKey, and AppSKey.
   * \param devAddr Device Address (8 hex characters).
   * \param nwkSKey Network Session Key (32 hex characters).
   * \param appSKey Application Session Key (32 hex characters).
   * \return True if personalization was accepted, false otherwise.
   */
  bool personalize(const char *devAddr, const char *nwkSKey, const char *appSKey);

  /**
   * \brief Completes the ABP process using previously set or stored DevAddr, NwkSKey, and AppSKey.
   * \return True if personalization was accepted, false otherwise.
   */
  bool personalize();

  /**
   * \brief Sends a byte array payload over LoRaWAN.
   * \param payload Pointer to the byte array.
   * \param length Size of the payload in bytes.
   * \param port LoRaWAN port number (1-223). Defaults to 1.
   * \param confirm True for a confirmed uplink, false for unconfirmed. Defaults to false.
   * \param sf Spreading Factor for this transmission. If 0, uses default or ADR. Defaults to 0.
   * \return A `ttn_response_t` code indicating the outcome.
   */
  ttn_response_t sendBytes(const uint8_t *payload, size_t length, port_t port = 1, bool confirm = false, uint8_t sf = 0);

  /**
   * \brief Sends an empty payload, often used to poll for downlink messages or confirm connectivity.
   * \param port LoRaWAN port number. Defaults to 1.
   * \param confirm True for a confirmed uplink. Defaults to false.
   * \return A `ttn_response_t` code indicating the outcome.
   */
  ttn_response_t poll(port_t port = 1, bool confirm = false);

  /**
   * \brief Puts the LoRaWAN module into sleep mode.
   * \param mseconds Duration to sleep in milliseconds (must be >= 100).
   */
  void sleep(uint32_t mseconds);

  /**
   * \brief Wakes the LoRaWAN module from sleep mode.
   */
  void wake();

  /**
   * \brief Saves the current MAC state of the LoRaWAN module to its non-volatile memory.
   */
  void saveState();

  /**
   * \brief Enables or disables periodic link checks.
   * \param seconds Interval in seconds for link check requests (0 to disable).
   */
  void linkCheck(uint16_t seconds);

  /**
   * \brief Gets the number of gateways that responded to the last link check.
   * \return Number of gateways.
   */
  uint8_t getLinkCheckGateways();

  /**
   * \brief Gets the demodulation margin (dB) of the last link check.
   * \return Link margin in dB.
   */
  uint8_t getLinkCheckMargin();
};

#endif // _THETHINGSNETWORK_HAN_IOT_H_
