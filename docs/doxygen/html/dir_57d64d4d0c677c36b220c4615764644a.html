<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IoT-muskrattrap: serverSide/nodered/node_modules/engine.io Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IoT-muskrattrap
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_57d64d4d0c677c36b220c4615764644a.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">engine.io Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for engine.io:</div>
<div class="dyncontent">
<div class="center"><img src="dir_57d64d4d0c677c36b220c4615764644a_dep.png" border="0" usemap="#adir__57d64d4d0c677c36b220c4615764644a__dep" loading="lazy" alt="serverSide/nodered/node_modules/engine.io"/></div>
<map name="adir__57d64d4d0c677c36b220c4615764644a__dep" id="adir__57d64d4d0c677c36b220c4615764644a__dep">
<area shape="rect" href="dir_b70c144eb3886bdbd98e130e312e150a.html" title="node_modules" alt="" coords="135,63,241,89"/>
<area shape="rect" href="dir_57d64d4d0c677c36b220c4615764644a.html" alt="" coords="27,52,252,99"/>
<area shape="rect" href="dir_1fe2c0d618eaa8bd2b6d3d78892e74a8.html" title="node_modules" alt="" coords="16,16,263,110"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-subdirs" class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:node_5Fmodules" id="r_node_5Fmodules"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_b70c144eb3886bdbd98e130e312e150a.html">node_modules</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md668"></a>
Engine.IO: the realtime engine</h1>
<p><a href="https://github.com/socketio/engine.io/actions"><img src="https://github.com/socketio/engine.io/workflows/CI/badge.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="http://badge.fury.io/js/engine.io"><img src="https://badge.fury.io/js/engine.io.svg" alt="NPM version" style="pointer-events: none;" class="inline"/></a></p>
<p><span class="tt">Engine.IO</span> is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for <a href="http://github.com/socketio/socket.io">Socket.IO</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md669"></a>
How to use</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md670"></a>
Server</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md671"></a>
(A) Listening on a port</h3>
<div class="fragment"><div class="line">const engine = require(&#39;engine.io&#39;);</div>
<div class="line">const server = engine.listen(80);</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connection&#39;, socket =&gt; {</div>
<div class="line">  socket.send(&#39;utf 8 string&#39;);</div>
<div class="line">  socket.send(Buffer.from([0, 1, 2, 3, 4, 5])); // binary data</div>
<div class="line">});</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md672"></a>
(B) Intercepting requests for a http.Server</h3>
<div class="fragment"><div class="line">const engine = require(&#39;engine.io&#39;);</div>
<div class="line">const http = require(&#39;http&#39;).createServer().listen(3000);</div>
<div class="line">const server = engine.attach(http);</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connection&#39;, socket =&gt; {</div>
<div class="line">  socket.on(&#39;message&#39;, data =&gt; { });</div>
<div class="line">  socket.on(&#39;close&#39;, () =&gt; { });</div>
<div class="line">});</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md673"></a>
(C) Passing in requests</h3>
<div class="fragment"><div class="line">const engine = require(&#39;engine.io&#39;);</div>
<div class="line">const server = new engine.Server();</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connection&#39;, socket =&gt; {</div>
<div class="line">  socket.send(&#39;hi&#39;);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// â€¦</div>
<div class="line">httpServer.on(&#39;upgrade&#39;, (req, socket, head) =&gt; {</div>
<div class="line">  server.handleUpgrade(req, socket, head);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">httpServer.on(&#39;request&#39;, (req, res) =&gt; {</div>
<div class="line">  server.handleRequest(req, res);</div>
<div class="line">});</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md674"></a>
Client</h2>
<div class="fragment"><div class="line">&lt;script src=&quot;/path/to/engine.io.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script&gt;</div>
<div class="line">  const socket = new eio.Socket(&#39;ws://localhost/&#39;);</div>
<div class="line">  socket.on(&#39;open&#39;, () =&gt; {</div>
<div class="line">    socket.on(&#39;message&#39;, data =&gt; {});</div>
<div class="line">    socket.on(&#39;close&#39;, () =&gt; {});</div>
<div class="line">  });</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>For more information on the client refer to the <a href="http://github.com/socketio/engine.io-client">engine-client</a> repository.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md675"></a>
What features does it have?</h1>
<ul>
<li><b>Maximum reliability</b>. Connections are established even in the presence of:<ul>
<li>proxies and load balancers.</li>
<li>personal firewall and antivirus software.</li>
<li>for more information refer to <b>Goals</b> and <b>Architecture</b> sections</li>
</ul>
</li>
<li><b>Minimal client size</b> aided by:<ul>
<li>lazy loading of flash transports.</li>
<li>lack of redundant transports.</li>
</ul>
</li>
<li><b>Scalable</b><ul>
<li>load balancer friendly</li>
</ul>
</li>
<li><b>Future proof</b></li>
<li><b>100% Node.JS core style</b><ul>
<li>No API sugar (left for higher level projects)</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md676"></a>
API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md677"></a>
Server</h2>
<hr  />
<p><br  />
</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md678"></a>
Top-level</h3>
<p>These are exposed by &lsquo;require('engine.io&rsquo;)`:</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md679"></a>
Events</h4>
<ul>
<li><span class="tt">flush</span><ul>
<li>Called when a socket buffer is being flushed.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Socket</span>: socket being flushed</li>
<li><span class="tt">Array</span>: write buffer</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">drain</span><ul>
<li>Called when a socket buffer is drained</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Socket</span>: socket being flushed</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md680"></a>
Properties</h4>
<ul>
<li><span class="tt">protocol</span> <em>(Number)</em>: protocol revision number</li>
<li><span class="tt">Server</span>: Server class constructor</li>
<li><span class="tt">Socket</span>: Socket class constructor</li>
<li><span class="tt">Transport</span> <em>(Function)</em>: transport constructor</li>
<li><span class="tt">transports</span> <em>(Object)</em>: map of available transports</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md681"></a>
Methods</h4>
<ul>
<li><p class="startli"><span class="tt">()</span></p><ul>
<li>Returns a new <span class="tt">Server</span> instance. If the first argument is an <span class="tt">http.Server</span> then the new <span class="tt">Server</span> instance will be attached to it. Otherwise, the arguments are passed directly to the <span class="tt">Server</span> constructor.</li>
<li><b>Parameters</b><ul>
<li><span class="tt">http.Server</span>: optional, server to attach to.</li>
<li><span class="tt">Object</span>: optional, options object (see <span class="tt">Server#constructor</span> api docs below)</li>
</ul>
</li>
</ul>
<p class="startli">The following are identical ways to instantiate a server and then attach it.</p>
</li>
</ul>
<div class="fragment"><div class="line">const httpServer; // previously created with `http.createServer();` from node.js api.</div>
<div class="line"> </div>
<div class="line">// create a server first, and then attach</div>
<div class="line">const eioServer = require(&#39;engine.io&#39;).Server();</div>
<div class="line">eioServer.attach(httpServer);</div>
<div class="line"> </div>
<div class="line">// or call the module as a function to get `Server`</div>
<div class="line">const eioServer = require(&#39;engine.io&#39;)();</div>
<div class="line">eioServer.attach(httpServer);</div>
<div class="line"> </div>
<div class="line">// immediately attach</div>
<div class="line">const eioServer = require(&#39;engine.io&#39;)(httpServer);</div>
<div class="line"> </div>
<div class="line">// with custom options</div>
<div class="line">const eioServer = require(&#39;engine.io&#39;)(httpServer, {</div>
<div class="line">  maxHttpBufferSize: 1e3</div>
<div class="line">});</div>
</div><!-- fragment --><ul>
<li><span class="tt">listen</span><ul>
<li>Creates an <span class="tt">http.Server</span> which listens on the given port and attaches WS to it. It returns <span class="tt">501 Not Implemented</span> for regular http requests.</li>
<li><b>Parameters</b><ul>
<li><span class="tt">Number</span>: port to listen on.</li>
<li><span class="tt">Object</span>: optional, options object</li>
<li><span class="tt">Function</span>: callback for <span class="tt">listen</span>.</li>
</ul>
</li>
<li><b>Options</b><ul>
<li>All options from <span class="tt">Server.attach</span> method, documented below.</li>
<li><b>Additionally</b> See Server <span class="tt">constructor</span> below for options you can pass for creating the new Server</li>
</ul>
</li>
<li><b>Returns</b> <span class="tt">Server</span></li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">const engine = require(&#39;engine.io&#39;);</div>
<div class="line">const server = engine.listen(3000, {</div>
<div class="line">  pingTimeout: 2000,</div>
<div class="line">  pingInterval: 10000</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connection&#39;, /* ... */);</div>
</div><!-- fragment --><ul>
<li><span class="tt">attach</span><ul>
<li>Captures <span class="tt">upgrade</span> requests for a <span class="tt">http.Server</span>. In other words, makes a regular http.Server WebSocket-compatible.</li>
<li><b>Parameters</b><ul>
<li><span class="tt">http.Server</span>: server to attach to.</li>
<li><span class="tt">Object</span>: optional, options object</li>
</ul>
</li>
<li><b>Options</b><ul>
<li>All options from <span class="tt">Server.attach</span> method, documented below.</li>
<li><b>Additionally</b> See Server <span class="tt">constructor</span> below for options you can pass for creating the new Server</li>
</ul>
</li>
<li><b>Returns</b> <span class="tt">Server</span> a new Server instance.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">const engine = require(&#39;engine.io&#39;);</div>
<div class="line">const httpServer = require(&#39;http&#39;).createServer().listen(3000);</div>
<div class="line">const server = engine.attach(httpServer, {</div>
<div class="line">  wsEngine: require(&#39;eiows&#39;).Server // requires having eiows as dependency</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">server.on(&#39;connection&#39;, /* ... */);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md682"></a>
Server</h3>
<p>The main server/manager. <em>Inherits from EventEmitter</em>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md683"></a>
Events</h4>
<ul>
<li><span class="tt">connection</span><ul>
<li>Fired when a new connection is established.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Socket</span>: a Socket object</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">initial_headers</span><ul>
<li>Fired on the first request of the connection, before writing the response headers</li>
<li><b>Arguments</b><ul>
<li><span class="tt">headers</span> (<span class="tt">Object</span>): a hash of headers</li>
<li><span class="tt">req</span> (<span class="tt">http.IncomingMessage</span>): the request</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">headers</span><ul>
<li>Fired on the all requests of the connection, before writing the response headers</li>
<li><b>Arguments</b><ul>
<li><span class="tt">headers</span> (<span class="tt">Object</span>): a hash of headers</li>
<li><span class="tt">req</span> (<span class="tt">http.IncomingMessage</span>): the request</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">connection_error</span><ul>
<li>Fired when an error occurs when establishing the connection.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">error</span>: an object with following properties:<ul>
<li><span class="tt">req</span> (<span class="tt">http.IncomingMessage</span>): the request that was dropped</li>
<li><span class="tt">code</span> (<span class="tt">Number</span>): one of <span class="tt">Server.errors</span></li>
<li><span class="tt">message</span> (<span class="tt">string</span>): one of <span class="tt">Server.errorMessages</span></li>
<li><span class="tt">context</span> (<span class="tt">Object</span>): extra info about the error</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Code  </th><th class="markdownTableHeadNone">Message  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">"Transport unknown"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">"Session ID unknown"  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">"Bad handshake method"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">"Bad request"  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">"Forbidden"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">"Unsupported protocol version"  </td></tr>
</table>
<h4 class="doxsection"><a class="anchor" id="autotoc_md684"></a>
Properties</h4>
<p><b>Important</b>: if you plan to use Engine.IO in a scalable way, please keep in mind the properties below will only reflect the clients connected to a single process.</p>
<ul>
<li><span class="tt">clients</span> <em>(Object)</em>: hash of connected clients by id.</li>
<li><span class="tt">clientsCount</span> <em>(Number)</em>: number of connected clients.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md685"></a>
Methods</h4>
<ul>
<li><b>constructor</b><ul>
<li>Initializes the server</li>
<li><b>Parameters</b><ul>
<li><span class="tt">Object</span>: optional, options object</li>
</ul>
</li>
<li><b>Options</b><ul>
<li><span class="tt">pingTimeout</span> (<span class="tt">Number</span>): how many ms without a pong packet to consider the connection closed (<span class="tt">20000</span>)</li>
<li><span class="tt">pingInterval</span> (<span class="tt">Number</span>): how many ms before sending a new ping packet (<span class="tt">25000</span>)</li>
<li><span class="tt">upgradeTimeout</span> (<span class="tt">Number</span>): how many ms before an uncompleted transport upgrade is cancelled (<span class="tt">10000</span>)</li>
<li><span class="tt">maxHttpBufferSize</span> (<span class="tt">Number</span>): how many bytes or characters a message can be, before closing the session (to avoid DoS). Default value is <span class="tt">1E6</span>.</li>
<li><span class="tt">allowRequest</span> (<span class="tt">Function</span>): A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not. The second argument is a function that needs to be called with the decided information: <span class="tt">fn(err, success)</span>, where <span class="tt">success</span> is a boolean value where false means that the request is rejected, and err is an error code.</li>
<li><span class="tt">transports</span> (<span class="tt">&lt;Array&gt; String</span>): transports to allow connections to (&lsquo;['polling&rsquo;, 'websocket']<span class="tt">)</span></li>
<li><span class="tt"></span>allowUpgrades<span class="tt"> (</span>Boolean<span class="tt">): whether to allow transport upgrades
        (</span>true<span class="tt">)</span></li>
<li><span class="tt"></span>perMessageDeflate<span class="tt"> (</span>Object|Boolean<span class="tt">): parameters of the WebSocket permessage-deflate extension
        (see [ws module](<a href="https://github.com/einaros/ws">https://github.com/einaros/ws</a>) api docs). Set to </span>true<span class="tt"> to enable. (defaults to </span>false<span class="tt">)<ul>
<li></li>
</ul>
</span>threshold<span class="tt"> (</span>Number<span class="tt">): data is compressed only if the byte size is above this value (</span>1024<span class="tt">)</span></li>
<li><span class="tt"></span>httpCompression<span class="tt"> (</span>Object|Boolean<span class="tt">): parameters of the http compression for the polling transports
        (see [zlib](<a href="http://nodejs.org/api/zlib.html">http://nodejs.org/api/zlib.html</a>#zlib_options) api docs). Set to </span>false<span class="tt"> to disable. (</span>true<span class="tt">)<ul>
<li></li>
</ul>
</span>threshold<span class="tt"> (</span>Number<span class="tt">): data is compressed only if the byte size is above this value (</span>1024<span class="tt">)</span></li>
<li><span class="tt"></span>cookie<span class="tt"> (</span>Object|Boolean<span class="tt">): configuration of the cookie that
        contains the client sid to send as part of handshake response
        headers. This cookie might be used for sticky-session. Defaults to not sending any cookie (</span>false<span class="tt">).
        See [here](<a href="https://github.com/jshttp/cookie">https://github.com/jshttp/cookie</a>#options-1) for all supported options.</span></li>
<li><span class="tt"></span>wsEngine<span class="tt"> (</span>Function<span class="tt">): what WebSocket server implementation to use. Specified module must conform to the </span>ws<span class="tt"> interface (see [ws module api docs](<a href="https://github.com/websockets/ws/blob/master/doc/ws.md">https://github.com/websockets/ws/blob/master/doc/ws.md</a>)). Default value is </span>ws<span class="tt">. An alternative c++ addon is also available by installing </span>eiows<span class="tt"> module.</span></li>
<li><span class="tt"></span>cors<span class="tt"> (</span>Object<span class="tt">): the options that will be forwarded to the cors module. See [there](<a href="https://github.com/expressjs/cors">https://github.com/expressjs/cors</a>#configuration-options) for all available options. Defaults to no CORS allowed.</span></li>
<li><span class="tt"></span>initialPacket<span class="tt"> (</span>Object<span class="tt">): an optional packet which will be concatenated to the handshake packet emitted by Engine.IO.</span></li>
<li><span class="tt"></span>allowEIO3<span class="tt"> (</span>Boolean<span class="tt">): whether to support v3 Engine.IO clients (defaults to </span>false<span class="tt">)</span></li>
</ul>
</li>
</ul>
</li>
<li><span class="tt"></span>close<span class="tt"><ul>
<li>Closes all clients</li>
<li>**Returns** </li>
</ul>
</span>Server<span class="tt"> for chaining</span></li>
<li><span class="tt"></span>handleRequest<span class="tt"><ul>
<li>Called internally when a </li>
</ul>
</span>Engine<span class="tt"> request is intercepted.<ul>
<li>**Parameters**<ul>
<li></li>
</ul>
</li>
</ul>
</span>http.IncomingMessage<span class="tt">: a node request object<ul>
<li></li>
</ul>
</span>http.ServerResponse<span class="tt">: a node response object<ul>
<li>**Returns** </li>
</ul>
</span>Server<span class="tt"> for chaining</span></li>
<li><span class="tt"></span>handleUpgrade<span class="tt"><ul>
<li>Called internally when a </li>
</ul>
</span>Engine<span class="tt"> ws upgrade is intercepted.<ul>
<li>**Parameters** (same as </li>
</ul>
</span>upgrade<span class="tt"> event)<ul>
<li></li>
</ul>
</span>http.IncomingMessage<span class="tt">: a node request object<ul>
<li></li>
</ul>
</span>net.Stream<span class="tt">: TCP socket for the request<ul>
<li></li>
</ul>
</span>Buffer<span class="tt">: legacy tail bytes<ul>
<li>**Returns** </li>
</ul>
</span>Server<span class="tt"> for chaining</span></li>
<li><span class="tt"></span>attach<span class="tt"><ul>
<li>Attach this Server instance to an </li>
</ul>
</span>http.Server<span class="tt"><ul>
<li>Captures </li>
</ul>
</span>upgrade<span class="tt"> requests for a </span>http.Server<span class="tt">. In other words, makes
      a regular http.Server WebSocket-compatible.<ul>
<li>**Parameters**<ul>
<li></li>
</ul>
</li>
</ul>
</span>http.Server<span class="tt">: server to attach to.<ul>
<li></li>
</ul>
</span>Object<span class="tt">: optional, options object<ul>
<li>**Options**<ul>
<li></li>
</ul>
</li>
</ul>
</span>path<span class="tt"> (</span>String<span class="tt">): name of the path to capture (</span>/engine.io<span class="tt">).<ul>
<li></li>
</ul>
</span>destroyUpgrade<span class="tt"> (</span>Boolean<span class="tt">): destroy unhandled upgrade requests (</span>true<span class="tt">)<ul>
<li></li>
</ul>
</span>destroyUpgradeTimeout<span class="tt"> (</span>Number<span class="tt">): milliseconds after which unhandled requests are ended (</span>1000<span class="tt">)</span></li>
<li><span class="tt"></span>generateId<span class="tt"><ul>
<li>Generate a socket id.</li>
<li>Overwrite this method to generate your custom socket id.</li>
<li>**Parameters**<ul>
<li></li>
</ul>
</li>
</ul>
</span>http.IncomingMessage`: a node request object<ul>
<li><b>Returns</b> A socket id for connected client.</li>
</ul>
</li>
</ul>
<hr  />
<p><br  />
</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md686"></a>
Socket</h3>
<p>A representation of a client. <em>Inherits from EventEmitter</em>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md687"></a>
Events</h4>
<ul>
<li><span class="tt">close</span><ul>
<li>Fired when the client is disconnected.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">String</span>: reason for closing</li>
<li><span class="tt">Object</span>: description object (optional)</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">message</span><ul>
<li>Fired when the client sends a message.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">String</span> or <span class="tt">Buffer</span>: Unicode string or Buffer with binary contents</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">error</span><ul>
<li>Fired when an error occurs.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Error</span>: error object</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">upgrading</span><ul>
<li>Fired when the client starts the upgrade to a better transport like WebSocket.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Object</span>: the transport</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">upgrade</span><ul>
<li>Fired when the client completes the upgrade to a better transport like WebSocket.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Object</span>: the transport</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">flush</span><ul>
<li>Called when the write buffer is being flushed.</li>
<li><b>Arguments</b><ul>
<li><span class="tt">Array</span>: write buffer</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">drain</span><ul>
<li>Called when the write buffer is drained</li>
</ul>
</li>
<li><span class="tt">packet</span><ul>
<li>Called when a socket received a packet (<span class="tt">message</span>, <span class="tt">ping</span>)</li>
<li><b>Arguments</b><ul>
<li><span class="tt">type</span>: packet type</li>
<li><span class="tt">data</span>: packet data (if type is message)</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">packetCreate</span><ul>
<li>Called before a socket sends a packet (<span class="tt">message</span>, <span class="tt">ping</span>)</li>
<li><b>Arguments</b><ul>
<li><span class="tt">type</span>: packet type</li>
<li><span class="tt">data</span>: packet data (if type is message)</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">heartbeat</span><ul>
<li>Called when <span class="tt">ping</span> or <span class="tt">pong</span> packed is received (depends of client version)</li>
</ul>
</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md688"></a>
Properties</h4>
<ul>
<li><span class="tt">id</span> <em>(String)</em>: unique identifier</li>
<li><span class="tt">server</span> <em>(Server)</em>: engine parent reference</li>
<li><span class="tt">request</span> <em>(http.IncomingMessage)</em>: request that originated the Socket</li>
<li><span class="tt">upgraded</span> <em>(Boolean)</em>: whether the transport has been upgraded</li>
<li><span class="tt">readyState</span> <em>(String)</em>: opening|open|closing|closed</li>
<li><span class="tt">transport</span> <em>(Transport)</em>: transport reference</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md689"></a>
Methods</h4>
<ul>
<li><span class="tt">send</span>:<ul>
<li>Sends a message, performing <span class="tt">message = toString(arguments[0])</span> unless sending binary data, which is sent as is.</li>
<li><b>Parameters</b><ul>
<li><span class="tt">String</span> |Â <span class="tt">Buffer</span> | <span class="tt">ArrayBuffer</span> | <span class="tt">ArrayBufferView</span>: a string or any object implementing <span class="tt">toString()</span>, with outgoing data, or a Buffer or ArrayBuffer with binary data. Also any ArrayBufferView can be sent as is.</li>
<li><span class="tt">Object</span>: optional, options object</li>
<li><span class="tt">Function</span>: optional, a callback executed when the message gets flushed out by the transport</li>
</ul>
</li>
<li><b>Options</b><ul>
<li><span class="tt">compress</span> (<span class="tt">Boolean</span>): whether to compress sending data. This option might be ignored and forced to be <span class="tt">true</span> when using polling. (<span class="tt">true</span>)</li>
</ul>
</li>
<li><b>Returns</b> <span class="tt">Socket</span> for chaining</li>
</ul>
</li>
<li><span class="tt">close</span><ul>
<li>Disconnects the client</li>
<li><b>Returns</b> <span class="tt">Socket</span> for chaining</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md690"></a>
Client</h2>
<hr  />
<p><br  />
</p>
<p>Exposed in the <span class="tt">eio</span> global namespace (in the browser), or by &lsquo;require('engine.io-client&rsquo;)` (in Node.JS).</p>
<p>For the client API refer to the <a href="http://github.com/learnboost/engine.io-client">engine-client</a> repository.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md691"></a>
Debug / logging</h1>
<p>Engine.IO is powered by <a href="http://github.com/visionmedia/debug">debug</a>. In order to see all the debug output, run your app with the environment variable <span class="tt">DEBUG</span> including the desired scope.</p>
<p>To see the output from all of Engine.IO's debugging scopes you can use:</p>
<div class="fragment"><div class="line">DEBUG=engine* node myapp</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md692"></a>
Transports</h1>
<ul>
<li><span class="tt">polling</span>: XHR / JSONP polling transport.</li>
<li><span class="tt">websocket</span>: WebSocket transport.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md693"></a>
Plugins</h1>
<ul>
<li><a href="https://github.com/EugenDueck/engine.io-conflation">engine.io-conflation</a>: Makes <b>conflation and aggregation</b> of messages straightforward.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md694"></a>
Support</h1>
<p>The support channels for <span class="tt">engine.io</span> are the same as <span class="tt">socket.io</span>:</p><ul>
<li>irc.freenode.net **#socket.io**</li>
<li><a href="http://groups.google.com/group/socket_io">Google Groups</a></li>
<li><a href="http://socket.io">Website</a></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md695"></a>
Development</h1>
<p>To contribute patches, run tests or benchmarks, make sure to clone the repository:</p>
<div class="fragment"><div class="line">git clone git://github.com/LearnBoost/engine.io.git</div>
</div><!-- fragment --><p>Then:</p>
<div class="fragment"><div class="line">cd engine.io</div>
<div class="line">npm install</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md696"></a>
Tests</h1>
<p>Tests run with <span class="tt">npm test</span>. It runs the server tests that are aided by the usage of <span class="tt">engine.io-client</span>.</p>
<p>Make sure <span class="tt">npm install</span> is run first.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md697"></a>
Goals</h1>
<p>The main goal of <span class="tt">Engine</span> is ensuring the most reliable realtime communication. Unlike the previous Socket.IO core, it always establishes a long-polling connection first, then tries to upgrade to better transports that are "tested" on the side.</p>
<p>During the lifetime of the Socket.IO projects, we've found countless drawbacks to relying on <span class="tt">HTML5 WebSocket</span> or <span class="tt">Flash Socket</span> as the first connection mechanisms.</p>
<p>Both are clearly the <em>right way</em> of establishing a bidirectional communication, with HTML5 WebSocket being the way of the future. However, to answer most business needs, alternative traditional HTTP 1.1 mechanisms are just as good as delivering the same solution.</p>
<p>WebSocket based connections have two fundamental benefits:</p>
<ol type="1">
<li><b>Better server performance</b><ul>
<li><em>A: Load balancers</em><br  />
 Load balancing a long polling connection poses a serious architectural nightmare since requests can come from any number of open sockets by the user agent, but they all need to be routed to the process and computer that owns the <span class="tt">Engine</span> connection. This negatively impacts RAM and CPU usage.</li>
<li><em>B: Network traffic</em><br  />
 WebSocket is designed around the premise that each message frame has to be surrounded by the least amount of data. In HTTP 1.1 transports, each message frame is surrounded by HTTP headers and chunked encoding frames. If you try to send the message <em>"Hello world"</em> with xhr-polling, the message ultimately becomes larger than if you were to send it with WebSocket.</li>
<li><em>C: Lightweight parser</em><br  />
 As an effect of <b>B</b>, the server has to do a lot more work to parse the network data and figure out the message when traditional HTTP requests are used (as in long polling). This means that another advantage of WebSocket is less server CPU usage.</li>
</ul>
</li>
<li><p class="startli"><b>Better user experience</b></p>
<p class="startli">Due to the reasons stated in point <b>1</b>, the most important effect of being able to establish a WebSocket connection is raw data transfer speed, which translates in <em>some</em> cases in better user experience.</p>
<p class="startli">Applications with heavy realtime interaction (such as games) will benefit greatly, whereas applications like realtime chat (Gmail/Facebook), newsfeeds (Facebook) or timelines (Twitter) will have negligible user experience improvements.</p>
</li>
</ol>
<p>Having said this, attempting to establish a WebSocket connection directly so far has proven problematic:</p>
<ol type="1">
<li><b>Proxies</b><br  />
 Many corporate proxies block WebSocket traffic.</li>
<li><b>Personal firewall and antivirus software</b><br  />
 As a result of our research, we've found that at least 3 personal security applications block WebSocket traffic.</li>
<li><b>Cloud application platforms</b><br  />
 Platforms like Heroku or No.de have had trouble keeping up with the fast-paced nature of the evolution of the WebSocket protocol. Applications therefore end up inevitably using long polling, but the seamless installation experience of Socket.IO we strive for (<em>"require() it and it just works"</em>) disappears.</li>
</ol>
<p>Some of these problems have solutions. In the case of proxies and personal programs, however, the solutions many times involve upgrading software. Experience has shown that relying on client software upgrades to deliver a business solution is fruitless: the very existence of this project has to do with a fragmented panorama of user agent distribution, with clients connecting with latest versions of the most modern user agents (Chrome, Firefox and Safari), but others with versions as low as IE 5.5.</p>
<p>From the user perspective, an unsuccessful WebSocket connection can translate in up to at least 10 seconds of waiting for the realtime application to begin exchanging data. This <b>perceptively</b> hurts user experience.</p>
<p>To summarize, <b>Engine</b> focuses on reliability and user experience first, marginal potential UX improvements and increased server performance second. <span class="tt">Engine</span> is the result of all the lessons learned with WebSocket in the wild.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md698"></a>
Architecture</h1>
<p>The main premise of <span class="tt">Engine</span>, and the core of its existence, is the ability to swap transports on the fly. A connection starts as xhr-polling, but it can switch to WebSocket.</p>
<p>The central problem this poses is: how do we switch transports without losing messages?</p>
<p><span class="tt">Engine</span> only switches from polling to another transport in between polling cycles. Since the server closes the connection after a certain timeout when there's no activity, and the polling transport implementation buffers messages in between connections, this ensures no message loss and optimal performance.</p>
<p>Another benefit of this design is that we workaround almost all the limitations of <b>Flash Socket</b>, such as slow connection times, increased file size (we can safely lazy load it without hurting user experience), etc.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md699"></a>
FAQ</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md700"></a>
Can I use engine without Socket.IO ?</h2>
<p>Absolutely. Although the recommended framework for building realtime applications is Socket.IO, since it provides fundamental features for real-world applications such as multiplexing, reconnection support, etc.</p>
<p><span class="tt">Engine</span> is to Socket.IO what Connect is to Express. An essential piece for building realtime frameworks, but something you <em>probably</em> won't be using for building actual applications.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md701"></a>
Does the server serve the client?</h2>
<p>No. The main reason is that <span class="tt">Engine</span> is meant to be bundled with frameworks. Socket.IO includes <span class="tt">Engine</span>, therefore serving two clients is not necessary. If you use Socket.IO, including</p>
<div class="fragment"><div class="line">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;</div>
</div><!-- fragment --><p>has you covered.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md702"></a>
Can I implement <span class="tt">Engine</span> in other languages?</h2>
<p>Absolutely. The <a href="https://github.com/socketio/engine.io-protocol">engine.io-protocol</a> repository contains the most up-to-date description of the specification at all times.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md703"></a>
License</h1>
<p>(The MIT License)</p>
<p>Copyright (c) 2014 Guillermo Rauch &lt;<a href="#" onclick="location.href='mai'+'lto:'+'gui'+'ll'+'erm'+'o@'+'lea'+'rn'+'boo'+'st'+'.co'+'m'; return false;">guill<span class="obfuscator">.nosp@m.</span>ermo<span class="obfuscator">.nosp@m.</span>@lear<span class="obfuscator">.nosp@m.</span>nboo<span class="obfuscator">.nosp@m.</span>st.co<span class="obfuscator">.nosp@m.</span>m</a>&gt;</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_27880ab04338f9dc09e25838fc9f82f1.html">serverSide</a></li><li class="navelem"><a href="dir_ea245d1371037254a9bc4ef873bc881e.html">nodered</a></li><li class="navelem"><a href="dir_1fe2c0d618eaa8bd2b6d3d78892e74a8.html">node_modules</a></li><li class="navelem"><a href="dir_57d64d4d0c677c36b220c4615764644a.html">engine.io</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
